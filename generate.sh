#! /bin/bash

WEBHOOK_NS=$(grep "namespace: " chart/values.yaml | sed s/'namespace: '//)
WEBHOOK_NAME=$(grep "fullname: " chart/values.yaml | sed s/'fullname: '//)
WEBHOOK_SVC=${WEBHOOK_NAME}.${WEBHOOK_NS}.svc
K8S_OUT_CERT_FILE=./chart/templates/app-certs.yaml

[ -z $WEBHOOK_NS ] && echo "Empty Webhook namespace. Please insert a value in chart/values.yaml" && exit -1
[ -z $WEBHOOK_NAME ] && echo "Empty Webhook name. Please insert a value in chart/values.yaml" && exit -1
if [ ! -x "$(command -v openssl)" ]; then
    echo "openssl not found"
    exit 1
fi

cat <<EOF > ./csr.conf
[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = ${WEBHOOK_NAME}
DNS.2 = ${WEBHOOK_NAME}.${WEBHOOK_NS}
DNS.3 = ${WEBHOOK_SVC}
EOF

echo "Generating keys for $WEBHOOK_SVC"

openssl genrsa -out ./server-key.pem 2048
openssl req -new -key ./server-key.pem -subj "/CN=system:node:${WEBHOOK_SVC} /O=system:nodes" -out ./server.csr -config ./csr.conf

# clean-up any previously created CSR for our service. Ignore errors if not present.
kubectl delete csr ${WEBHOOK_SVC} 2>/dev/null || true

# create  server cert/key CSR and  send to k8s API
echo "Creating cert/key CSR in Kube"

cat <<EOF | kubectl create -f -
apiVersion: certificates.k8s.io/v1beta1
kind: CertificateSigningRequest
metadata:
  name: ${WEBHOOK_SVC}
spec:
  groups:
  - system:authenticated
  request: $(< ./server.csr base64 | tr -d '\n')
  signerName: kubernetes.io/kubelet-serving
  usages:
  - digital signature
  - key encipherment
  - server auth
EOF

[ $? -eq 0 ] || echo "Error submitting CertificateSigningRequest" || exit -1

# verify CSR has been created
while true; do
    if kubectl get csr ${WEBHOOK_SVC}; then
        break
    fi
done

echo "Approve cert in kube"

kubectl certificate approve ${WEBHOOK_SVC}
# verify certificate has been signed
for _ in $(seq 10); do
    serverCert=$(kubectl get csr ${WEBHOOK_SVC} -o jsonpath='{.status.certificate}')
    if [[ ${serverCert} != '' ]]; then
        break
    fi
    sleep 1
done
if [[ ${serverCert} == '' ]]; then
    echo "ERROR: After approving csr ${WEBHOOK_SVC}, the signed certificate did not appear on the resource. Giving up after 10 attempts." >&2
    exit 1
fi
echo "${serverCert}" | openssl base64 -d -A -out ./server-cert.pem

echo "Generate yaml file to create secrets"

# Generate yaml file to create secrets
kubectl -n ${WEBHOOK_NS} create secret generic ${WEBHOOK_NAME}-certs \
    --from-file=key.pem=./server-key.pem \
    --from-file=cert.pem=./server-cert.pem \
    --dry-run=client -o yaml > ${K8S_OUT_CERT_FILE}


# Set the CABundle on the webhook registration.
echo "Fetching certificate authority from Kube cluster"

CA_BUNDLE=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')
[ -z $CA_BUNDLE ] && echo "Empty CA_BUNDLE" && exit -1
sed -Ei "s/caBundle:.*/caBundle: ${CA_BUNDLE}/" ./chart/values.yaml

# Clean
echo 0 > server-key.pem
rm -f server.csr && rm -f server-key.pem && rm -f server-cert.pem && rm -f csr.conf

# Add note of autogenerated file.
sed -i '1i# File autogenerated by script generate.sh' ${K8S_OUT_CERT_FILE}

echo "Chart ready to be deployed. Happy helming!"